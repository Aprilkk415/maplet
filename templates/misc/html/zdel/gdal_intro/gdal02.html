{% extends "../../../../theme/content.html" %}

{% block headinfo %}


<title>GDAL驱动实现向导</title>
{% end %}


{% block content %}

<div class="content">

    <div class="single">

        <h1>GDAL驱动实现向导</h1>

        <div class="entry">


            <em> <b>翻译：</b>柴树杉(<a href="mailto:chaishushan@gmail.com">chaishushan@gmail.com</a>) <br>
                <b>原文：</b><a href="http://www.gdal.org/gdal_drivertut.html">http://www.gdal.org/gdal_drivertut.html</a>
                <br>
            </em>

            <p>
                通常，可以重新继承GDALDataset和GDALRasterBand来实现对特定格式数据的支持。 同样，还需要为这种格式创建一个GDALDriver的实例，让后通过GDALDriverManager将
                驱动注册给GDAL系统。</p>

            <p>
                该教程将为JDEM格式数据实现一个简单的只读驱动开始，进而使用RawRasterBand帮助类， 实现一个可创建和更改的格式以及比较高级的一些问题。</p>

            <p>
                强烈建议在实现GDAL驱动之前前面所描述的GDAL数据模型的内容。</p>

            <h2><a class="anchor" name="gdal_drivertut_toc">
                目录</a></h2>
            <ol>
                <li>
                    <a class="el" href="#gdal_drivertut_dataset">子类化Dataset</a></li>
                <li>
                    <a class="el" href="#gdal_drivertut_rasterband">子类化RasterBand</a></li>
                <li>
                    <a class="el" href="#gdal_drivertut_driver">驱动</a></li>
                <li>
                    <a class="el" href="#gdal_drivertut_addingdriver">将驱动添加到GDAL中</a></li>
                <li>
                    <a class="el" href="#gdal_drivertut_georef">添加参照系</a></li>
                <li>
                    <a class="el" href="#gdal_drivertut_overviews">Overview</a></li>
                <li>
                    <a class="el" href="#gdal_drivertut_creation">创建文件</a></li>
                <li>
                    <a class="el" href="#gdal_drivertut_raw">RawDataset/RawRasterBand Helper Classes</a></li>
                <li>
                    <a class="el" href="#gdal_drivertut_metadata">元数据以及其他扩展</a></li>
            </ol>
            <h2><a class="anchor" name="gdal_drivertut_dataset">
                子类化Dataset</a></h2>
            将将演示一个小日本DEM驱动的最基本的实现。首先，从GDALDataset继承一个 子类JDEMDataset，JDEMDataset对应小日本格式DEM数据。<p>
        </p>

            <div class="fragment"><pre class="fragment"><span class="keyword">class </span>JDEMDataset : <span
                    class="keyword">public</span> GDALDataset
{
    FILE        *fp;
    GByte       abyHeader[1012];

  <span class="keyword">public</span>:
                ~JDEMDataset();

    <span class="keyword">static</span> GDALDataset *Open( GDALOpenInfo * );
};
</pre>
            </div>
            <p>
                我们可以通过重载基类GDALDataset中的一些虚函数来为驱动重新实现某些特殊的 功能。然而，Open()相对比较特殊，它不是基类 GDALDataset的虚函数。我们
                需要一个独立的函数来实现这个功能，因此我们把他声明为static的。将Open()声明 为 JDEMDataset的static函数比较方便，因为这样可以用JDEMDataset的私有方法去
                修改内容。</p>

            <p>
                Open()函数具体实现如下：</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">GDALDataset *JDEMDataset::Open( GDALOpenInfo * poOpenInfo )

{
// --------------------------------------------------------------------
//      Before trying JDEMOpen() we first verify that there is at
//      least one "\n#keyword" type signature in the first chunk of
//      the file.
// --------------------------------------------------------------------
    if( poOpenInfo-&gt;fp == NULL || poOpenInfo-&gt;nHeaderBytes &lt; 50 )
        return NULL;

    // check if century values seem reasonable
    if( (!EQUALN((char *)poOpenInfo-&gt;pabyHeader+11,"19",2)
          &amp;&amp; !EQUALN((char *)poOpenInfo-&gt;pabyHeader+11,"20",2))
        || (!EQUALN((char *)poOpenInfo-&gt;pabyHeader+15,"19",2)
             &amp;&amp; !EQUALN((char *)poOpenInfo-&gt;pabyHeader+15,"20",2))
        || (!EQUALN((char *)poOpenInfo-&gt;pabyHeader+19,"19",2)
             &amp;&amp; !EQUALN((char *)poOpenInfo-&gt;pabyHeader+19,"20",2)) )
    {
        return NULL;
    }

// --------------------------------------------------------------------
//      Create a corresponding GDALDataset.
// --------------------------------------------------------------------
    JDEMDataset 	*poDS;

    poDS = new JDEMDataset();

    poDS-&gt;fp = poOpenInfo-&gt;fp;
    poOpenInfo-&gt;fp = NULL;

// --------------------------------------------------------------------
//      Read the header.
// --------------------------------------------------------------------
    VSIFSeek( poDS-&gt;fp, 0, SEEK_SET );
    VSIFRead( poDS-&gt;abyHeader, 1, 1012, poDS-&gt;fp );

    poDS-&gt;nRasterXSize = JDEMGetField( (char *) poDS-&gt;abyHeader + 23, 3 );
    poDS-&gt;nRasterYSize = JDEMGetField( (char *) poDS-&gt;abyHeader + 26, 3 );

// --------------------------------------------------------------------
//      Create band information objects.
// --------------------------------------------------------------------
    poDS-&gt;nBands = 1;
    poDS-&gt;SetBand( 1, new JDEMRasterBand( poDS, 1 ));

    return( poDS );
}
</pre>
            </div>
            <p>
                任何数据集打开文件之前，都要判断驱动是否支持该类型。我们应该知道， 在打开文件的时候每个驱动的open函数将被依次调用，直到有一个成功为止。
                如果传递的文件不是驱动所支持的类型，则它们必须返回NULL。如果格式是它们所 支持的类型，但是数据已经被破坏，那么它们应该产生一个错误。</p>

            <p>
                文件的信息在文件打开之后被传递给GDALOpenInfo对象。GDALOpenInfo对象的公有成员如下：</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    <span class="keywordtype">char</span>        *pszFilename;

    GDALAccess  eAccess; <span class="comment">// GA_ReadOnly or GA_Update</span>

    GBool       bStatOK;
    VSIStatBuf  sStat;

    FILE        *fp;

    <span class="keywordtype">int</span>         nHeaderBytes;
    GByte       *pabyHeader;
</pre>
            </div>
            <p>
                驱动可以检查这些值来判断是否支持这个格式的文件。如果pszFilename指向 一个文件系统对象，那么bStatOK将被设置，并且sStat结构将包含关于对象的
                通用信息。如果对象是一个规则的可读文件，那么fp指针将非空，并且可以使 用fp来读取文件（请使用cpl_vsi.h中标准输入输出文件）。最后，如果文件可以
                被打开，那么开头的近1K字节的数据将被读到pabyHeader中，nHeaderBytes保存 实际读取的字节数。</p>

            <p>
                在这个例子中，假设文件已经被打开并且可以测试文件头部的一些信息。在这里， JDEM并没有魔术数字，因此我们只是检测不同的数据域。如果文件不是当前驱动所 支持的格式，那么将返回NULL。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span>( poOpenInfo-&gt;fp == NULL || poOpenInfo-&gt;nHeaderBytes &lt; 50 )
        <span class="keywordflow">return</span> NULL;

    <span class="comment">// check if century values seem reasonable</span>
    <span class="keywordflow">if</span>( (!EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+11,<span
                        class="stringliteral">"19"</span>,2)
          &amp;&amp; !EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+11,<span
                        class="stringliteral">"20"</span>,2))
        || (!EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+15,<span class="stringliteral">"19"</span>,2)
             &amp;&amp; !EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+15,<span
                        class="stringliteral">"20"</span>,2))
        || (!EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+19,<span class="stringliteral">"19"</span>,2)
             &amp;&amp; !EQUALN((<span class="keywordtype">char</span> *)poOpenInfo-&gt;pabyHeader+19,<span
                        class="stringliteral">"20"</span>,2)) )
    {
        <span class="keywordflow">return</span> NULL;
    }
</pre>
            </div>
            <p>
                在真正的测试中，测试代码越严格越好。这里的测试相对比较弱。如果一个文件的 在相应的位置具有相同的内容，那么它们很可能被错误地当作JDEM格式处理，最终 导致不可预期的结果。</p>

            <p>
                如果文件是我们支持的类型，我们需要创建一个database的实例，并在database中 记录必要的信息。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    JDEMDataset         *poDS;

    poDS = <span class="keyword">new</span> JDEMDataset();

    poDS-&gt;fp = poOpenInfo-&gt;fp;
    poOpenInfo-&gt;fp = NULL;
</pre>
            </div>
            <p>
                通常在这个时刻我们将打开文件（这里已经打开了），并且保存文件的指针。 然而，如果只是只读的话，仅仅从GDALOpenInfo中获取文件的指针也是可以的。
                在这里我们将GDALOpenInfo的文件指针设置为NULL，以防止文件可能被关闭两次 （因为JDEMDataset的析构函数中已经关闭了文件）。同样，我们假设文件的当前读写
                状态是不确定的，因此我们需要用VSIFSeek()重新定位文件的当前地址。下面的两行 代码完成了重新定位和读文件头的工作。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    VSIFSeek( poDS-&gt;fp, 0, SEEK_SET );
    VSIFRead( poDS-&gt;abyHeader, 1, 1012, poDS-&gt;fp );
</pre>
            </div>
            <p>
                接着，从abyHeader中获取x和y的大小。变量nRasterXSize和nRasterYSize是 从基类GDALDataset中继承的，并且必须在Open()中被设置。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    poDS-&gt;nRasterXSize = JDEMGetField( (<span
                    class="keywordtype">char</span> *) poDS-&gt;abyHeader + 23, 3 );
    poDS-&gt;nRasterYSize = JDEMGetField( (<span class="keywordtype">char</span> *) poDS-&gt;abyHeader + 26, 3 );
</pre>
            </div>
            <p>
                最后，通过SetBand()将所有的波段与当前的GDALDataset对象绑定。在下一节， 我们将讨论JDEMRasterBand类的具体细节。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    poDS-&gt;SetBand( 1, <span class="keyword">new</span> JDEMRasterBand( poDS, 1 ));

    <span class="keywordflow">return</span>( poDS );
</pre>
            </div>
            <h2><a class="anchor" name="gdal_drivertut_rasterband">
                子类化RasterBand</a></h2>
            和常规的从JDEMDataset继承的子类一样，我们需要为JDEMRasterBand定义一个 接受每个波段数据的一致的入口。JDEMRasterBand类的定义如下：<p>
        </p>

            <div class="fragment"><pre class="fragment"><span class="keyword">class </span>JDEMRasterBand : <span
                    class="keyword">public</span> GDALRasterBand
{
  <span class="keyword">public</span>:
                JDEMRasterBand( JDEMDataset *, <span class="keywordtype">int</span> );
    <span class="keyword">virtual</span> CPLErr IReadBlock( <span class="keywordtype">int</span>, <span
                        class="keywordtype">int</span>, <span class="keywordtype">void</span> * );
};
</pre>
            </div>
            <p>
                构造函数可以任意定义，但是只能从Open()函数中调用。其他的虚函数必须 和gdal_priv.h中定义的一致，例如IReadBlock()。构造函数实现代码如下：</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">JDEMRasterBand::JDEMRasterBand( JDEMDataset *poDS, <span
                    class="keywordtype">int</span> nBand )

{
    this-&gt;poDS = poDS;
    this-&gt;nBand = nBand;

    eDataType = GDT_Float32;

    nBlockXSize = poDS-&gt;GetRasterXSize();
    nBlockYSize = 1;
}
</pre>
            </div>
            <p>
                下面成员变量从GDALRasterBand继承，并且通常在构造函数中设置。</p>

            <p>
            </p>
            <ul>
                <li>
                    <b>poDS</b>: 基类GDALDataset指针。
                </li>
                <li>
                    <b>nBand</b>: 对应dataset中的波段编号。
                </li>
                <li>
                    <b>eDataType</b>: 像素在该波段中的数据类型。
                </li>
                <li>
                    <b>nBlockXSize</b>: 该波段的宽度。
                </li>
                <li>
                    <b>nBlockYSize</b>: 该波段的高度。
                </li>
            </ul>
            <p>
                所有的GDALDataType类型在gdal.h文件中定义，包括GDT_Byte、GDT_UInt16、 GDT_Int16和 GDT_Float32。块的尺寸（block
                size）记录数据的实际或有效的大小。 对于约束数据集这将是一个约束尺寸，而对于其他大多数数据而言这将是一个扫描线。</p>

            <p>
                接下来，我们将实现真正读取影象数据的代码——IReadBlock()。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">CPLErr JDEMRasterBand::IReadBlock( <span
                    class="keywordtype">int</span> nBlockXOff, <span class="keywordtype">int</span> nBlockYOff,
                                  <span class="keywordtype">void</span> * pImage )

{
    JDEMDataset *poGDS = (JDEMDataset *) poDS;
    <span class="keywordtype">char</span>        *pszRecord;
    <span class="keywordtype">int</span>         nRecordSize = nBlockXSize*5 + 9 + 2;
    <span class="keywordtype">int</span>         i;

    VSIFSeek( poGDS-&gt;fp, 1011 + nRecordSize*nBlockYOff, SEEK_SET );

    pszRecord = (<span class="keywordtype">char</span> *) CPLMalloc(nRecordSize);
    VSIFRead( pszRecord, 1, nRecordSize, poGDS-&gt;fp );

    <span class="keywordflow">if</span>( !EQUALN((<span class="keywordtype">char</span> *) poGDS-&gt;abyHeader,pszRecord,6) )
    {
        CPLFree( pszRecord );

        CPLError( CE_Failure, CPLE_AppDefined,
                  <span class="stringliteral">"JDEM Scanline corrupt.  Perhaps file was not transferred\n"</span>
                  <span class="stringliteral">"in binary mode?"</span> );
        <span class="keywordflow">return</span> CE_Failure;
    }

    <span class="keywordflow">if</span>( JDEMGetField( pszRecord + 6, 3 ) != nBlockYOff + 1 )
    {
        CPLFree( pszRecord );

        CPLError( CE_Failure, CPLE_AppDefined,
                  <span class="stringliteral">"JDEM scanline out of order, JDEM driver does not\n"</span>
                  <span class="stringliteral">"currently support partial datasets."</span> );
        <span class="keywordflow">return</span> CE_Failure;
    }

    <span class="keywordflow">for</span>( i = 0; i &lt; nBlockXSize; i++ )
        ((<span class="keywordtype">float</span> *) pImage)[i] = JDEMGetField( pszRecord + 9 + 5 * i, 5) * 0.1;

    <span class="keywordflow">return</span> CE_None;
}
</pre>
            </div>
            <p>
                需要注意的地方：</p>

            <p>
            </p>
            <ul>
                <li>
                    把<code>GDALRasterBand::poDS</code>成员传递给子类是常用的做法。如果你的RasterBand需要
                    操作dataset的私有成员，确保将它声明为JDEMRasterBand类的友元。<p>
                </p></li>
                <li>
                    如果发生错误，用CPLError()报告错误信息，并且返回Failure错误标志。 否则返回None。<p>
                </p></li>
                <li>
                    pImage缓冲必须用一个块的数据来填充。块的大小在JDEMRasterBand的 nBlockXSize/nBlockYSize中定义。pImage缓冲的数据类型为JDEMRasterBand中
                    的eDataType对应的类型。<p>
                </p></li>
                <li>
                    nBlockXOff/nBlockYOff是块的开始地址。因此，对于一个声明为128*128大小的块， 则开始地址为1/1的块对应的数据为(128,128)到(256,256)。<p>
                </p></li>
            </ul>
            <h2><a class="anchor" name="gdal_drivertut_driver">
                驱动</a></h2>
            虽然JDEMDataset和JDEMRasterBand已经可以读数据，但是GDAL仍然不知道关于 JDEMDataset驱动的任何信息。这可以通过GDALDriverManager来实现。为了注册我们
            自己实现的驱动，我们需要重新实现一个注册函数：<p>
        </p>

            <div class="fragment"><pre class="fragment">CPL_C_START
<span class="keywordtype">void</span>    GDALRegister_JDEM(<span class="keywordtype">void</span>);
CPL_C_END

...

void GDALRegister_JDEM()

{
    GDALDriver  *poDriver;

    <span class="keywordflow">if</span>( GDALGetDriverByName( <span class="stringliteral">"JDEM"</span> ) == NULL )
    {
        poDriver = <span class="keyword">new</span> GDALDriver();

        poDriver-&gt;SetDescription( <span class="stringliteral">"JDEM"</span> );
        poDriver-&gt;SetMetadataItem( GDAL_DMD_LONGNAME,
                                   <span class="stringliteral">"Japanese DEM (.mem)"</span> );
        poDriver-&gt;SetMetadataItem( GDAL_DMD_HELPTOPIC,
                                   <span class="stringliteral">"frmt_various.html#JDEM"</span> );
        poDriver-&gt;SetMetadataItem( GDAL_DMD_EXTENSION, <span class="stringliteral">"mem"</span> );

        poDriver-&gt;pfnOpen = JDEMDataset::Open;

        GetGDALDriverManager()-&gt;RegisterDriver( poDriver );
    }
}
</pre>
            </div>
            <p>
                当第一次被调用的时候，注册函数将new一个GDALDriver对象，并且通过GDALDriverManager来注册。在用GDALDriverManager注册驱动之前，需要设置以下的成员变量：</p>

            <p>
            </p>
            <ul>
                <li>
                    驱动对应格式的名称，不能和其他驱动名字冲突。通常在3-5个字符长度， 并且匹配驱动类名字的前缀。（手工设置）<p>
                </p></li>
                <li>
                    GDAL_DMD_LONGNAME: 文件格式的详细描述，长度一般在50-60个字符。（手工设置）<p>
                </p></li>
                <li>
                    GDAL_DMD_HELPTOPIC: 如果存在的话，是关于这个驱动帮助主题的名称。 在这个例子中，JDEM格式包含在frmt_various.html::JDEM位置描述。（可选）<p>
                </p></li>
                <li>
                    GDAL_DMD_EXTENSION: 该类型文件的扩展名。如果扩展名多于一个， 则最好选择最通用的那个，或者直接为空。（可选）<p>
                </p></li>
                <li>
                    GDAL_DMD_MIMETYPE: 该格式数据的标准用途类型，例如“image/png”。（可选）<p>
                </p></li>
                <li>
                    GDAL_DMD_CREATIONOPTIONLIST: 用于描述创建时的选项。可以参考geotiff驱动 的实现代码。（可选）<p>
                </p></li>
                <li>
                    GDAL_DMD_CREATIONDATATYPES: 支持创建数据集的全部类型列表。如果存 在Create()方法这些类型都将被支持。如果存在CreateCopy()方法，该类型列表将
                    是那些支持无损输出的类型。例如，一个格式使用了CreateCopy()方法，如果可以 写为Float32类型，那么Byte、Int16和UInt16都应该被支持（因为它们都可以用Float32表示）。
                    一个同样的例子是“Byte Int16 UInt16”。（如果支持创建则需要）<p>
                </p></li>
                <li>
                    pfnOpen: 打开这种格式文件的函数。（可选）<p>
                </p></li>
                <li>
                    pfnCreate: 创建这个格式的updatable模式的数据集的函数。（可选）<p>
                </p></li>
                <li>
                    pfnCreateCopy: 创建从其它数据源拷贝而来的这种格式的新数据集， 但是不需要更新的函数。（可选）<p>
                </p></li>
                <li>
                    pfnDelete: 删除这种格式数据集函数。（可选）<p>
                </p></li>
                <li>
                    pfnUnloadDriver: 这个函数只有在驱动被销毁的时候才被调用。 在驱动层被用来清除数据。很少用到。（可选）<p>
                </p></li>
            </ul>
            <h2><a class="anchor" name="gdal_drivertut_addingdriver">
                将驱动添加到GDAL中</a></h2>
            GDALRegister_JDEM()函数必须被更高层次的函数调用以生成关于JDEM的驱动。通常实现一个驱动的时候需要做以下事情：<p>
        </p>
            <ol>
                <li>
                    在gdal/frmts下创建一个驱动目录，目录的名字和驱动的短名字相同。<p>
                </p></li>
                <li>
                    在驱动的目录中添加GNUmakefile和makefile.vc两个文件，具体的格式可以 参考其他驱动目录。（例如jdem目录）<p>
                </p></li>
                <li>
                    为dataset和rasterband添加实现模块。通常情况下是调用一个 &lt;short_name&gt;dataset.cpp文件（这里为jdemdataset.cpp）。该文件一般放置
                    关于GDAL的特殊代码，当然这不是必须的。<p>
                </p></li>
                <li>
                    在gdal/gcore/gdal_frmts.h文件中添加注册入口点声明（这里为GDALRegister_JDEM()）。<p>
                </p></li>
                <li>
                    在frmts/gdalallregister.c文件中添加一个注册函数的调用， 最好是在ifdef之间（可以参考已有的代码）。<p>
                </p></li>
                <li>
                    在GDALmake.opt.in(和GDALmake.opt)文件中的GDAL_FORMATS宏中添加格式短名称。<p>
                </p></li>
                <li>
                    在frmts/makefile.vc的EXTRAFLGS宏中添加格式特别项。
                </li>
            </ol>
            <p>
                一旦所有的这些操作都完成，我们将重新构件GDAL，并且所有的应用程序都将识别 新的格式。gdalinfo程序可以用来测打开数据和显示信息。gdal_translate可以用 来测试影象的读操作。</p>

            <h2><a class="anchor" name="gdal_drivertut_georef">
                添加参照系</a></h2>
            现在我们继续晚上这个驱动，并添加参照系的支持。我们将在JDEMDataset中重新实现 两个虚函数，注意要和GDALRasterDataset中函数一致。<p>
        </p>

            <div class="fragment"><pre class="fragment">    CPLErr      GetGeoTransform( <span class="keywordtype">double</span> * padfTransform );
    <span class="keyword">const</span> <span class="keywordtype">char</span> *GetProjectionRef();
</pre>
            </div>
            <p>
                重新实现的GetGeoTransform()函数只是复制地理转换矩阵到缓冲。GetGeoTransform() 函数可能经常使用，因此一般最好保持该函数短小。在许多时候，在Open()函数
                将收集地理转换，并且用这个函数复制。需要注意的是，转换矩阵对应像素左上角 为原点，而不是中心。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">CPLErr JDEMDataset::GetGeoTransform( <span class="keywordtype">double</span> * padfTransform )

{
    <span class="keywordtype">double</span>      dfLLLat, dfLLLong, dfURLat, dfURLong;

    dfLLLat = JDEMGetAngle( (<span class="keywordtype">char</span> *) abyHeader + 29 );
    dfLLLong = JDEMGetAngle( (<span class="keywordtype">char</span> *) abyHeader + 36 );
    dfURLat = JDEMGetAngle( (<span class="keywordtype">char</span> *) abyHeader + 43 );
    dfURLong = JDEMGetAngle( (<span class="keywordtype">char</span> *) abyHeader + 50 );

    padfTransform[0] = dfLLLong;
    padfTransform[3] = dfURLat;
    padfTransform[1] = (dfURLong - dfLLLong) / GetRasterXSize();
    padfTransform[2] = 0.0;

    padfTransform[4] = 0.0;
    padfTransform[5] = -1 * (dfURLat - dfLLLat) / GetRasterYSize();


    <span class="keywordflow">return</span> CE_None;
}
</pre>
            </div>
            <p>
                GetProjectionRef() 方法将返回一个字符串，其中包括OGC WKT格式的坐标系统 的定义。在这个例子中，坐标系统适合于这种格式的所有数据。但是在比较复杂的 数据格式中，我们可以需要使用
                OGRSpatialReference得到针对与特定情形的更具体 的坐标系统。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span> *JDEMDataset::GetProjectionRef()

{
    <span class="keywordflow">return</span>( <span class="stringliteral">"GEOGCS[\"Tokyo\",DATUM[\"Tokyo\",SPHEROID[\"Bessel 1841\","</span>
        <span class="stringliteral">"6377397.155,299.1528128,AUTHORITY[\"EPSG\",7004]],TOWGS84[-148,"</span>
        <span class="stringliteral">"507,685,0,0,0,0],AUTHORITY[\"EPSG\",6301]],PRIMEM[\"Greenwich\","</span>
        <span class="stringliteral">"0,AUTHORITY[\"EPSG\",8901]],UNIT[\"DMSH\",0.0174532925199433,"</span>
        <span class="stringliteral">"AUTHORITY[\"EPSG\",9108]],AXIS[\"Lat\",NORTH],AXIS[\"Long\",EAST],"</span>
        <span class="stringliteral">"AUTHORITY[\"EPSG\",4301]]"</span> );
}
</pre>
            </div>
            <p>
                到这里已经能够完成了JDEM驱动的部分特征代码，我们重新回顾一下前面的代码。</p>

            <h2><a class="anchor" name="gdal_drivertut_overviews">
                Overview</a></h2>
            GDAL allows file formats to make pre-built overviews available to applications via the
            GDALRasterBand::GetOverview() and related methods. However, implementing this is pretty involved, and goes
            beyond the scope of this document for now. The GeoTIFF driver (gdal/frmts/gtiff/geotiff.cpp) and related
            source can be reviewed for an example of a file format implementing overview reporting and creation support.
            <p>
                Formats can also report that they have arbitrary overviews, by overriding the HasArbitraryOverviews()
                method on the GDALRasterBand, returning TRUE. In this case the raster band object is expected to
                override the RasterIO() method itself, to implement efficient access to imagery with resampling. This is
                also involved, and there are a lot of requirements for correct implementation of the RasterIO() method.
                An example of this can be found in the OGDI and ECW formats.</p>

            <p>
                However, by far the most common approach to implementing overviews is to use the default support in GDAL
                for external overviews stored in TIFF files with the same name as the dataset, but the extension .ovr
                appended. In order to enable reading and creation of this style of overviews it is necessary for the
                GDALDataset to initialize the oOvManager object within itself. This is typically accomplished with a
                call like the following near the end of the Open() method.</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    poDS-&gt;oOvManager.Initialize( poDS, poOpenInfo-&gt;pszFilename );
</pre>
            </div>
            <p>
                This will enable default implementations for reading and creating overviews for the format. It is
                advised that this be enabled for all simple file system based formats unless there is a custom overview
                mechanism to be tied into.</p>

            <h2><a class="anchor" name="gdal_drivertut_creation">
                创建文件</a></h2>
            有两种方法创建文件。第一种是调用CreateCopy()函数，包含以输出格式写影象 的函数和从源影象中获取信息的函数。第二种是调用Create动态创建文件， 包含Create函数和用来设置各种信息的函数。<p>
            第一种方法的优点是在创建文件的所有的信息都被输出。对于通过在文件创建时需要例如颜 色图，参照系外在库实现文件格式是特别重要的。关于这种方法其他的优点是CreateCopy方法
            读取各种没有相应的设置方法的信息，例如min/max、scaling、description和GCPs。</p>

            <p>
                第二种方法的优点在于可以创建一个空的新文件，并且在需要的时候把结果写入其中。 对于一个影象来说，动态创建不需要提前获取所有信息。</p>

            <p>
                对于比较重要的格式而言，两种方法最好都支持。</p>

            <h3><a class="anchor" name="gdal_drivertut_creation_createcopy">
                CreateCopy</a></h3>
            <code>GDALDriver::CreateCopy()</code>方法可以直接调用，因此只需要知道调用的参数既可。不过以下的细节需要注意：<p>
        </p>
            <ul>
                <li>
                    如果为FALSE，那么驱动器将对数据自行做一些合适的处理。 特别是对于那些并不完全等同格式。<p>
                </p></li>
                <li>
                    可以实现CreateCopy进度提示。回调函数的返回值需要被检测以确定是 否需要继续进行，并且过程最好是在合理的时间片被调用（这个例子并没有示范）。<p>
                </p></li>
                <li>
                    特殊的创建选项必须在帮助中说明。如果存在"NAME=VALUE"的格式，表明
                    JPEGCreateCopy()函数将通过CPLFetchNameValue()函数设置QUALITY和PROGRESSIVE标志的。<p>
                </p></li>
                <li>
                    返回的GDALDataset句柄是只读或者更新模式。在实用情况下返回更新模式， 否则返回只读模式即可。<p>
                </p></li>
            </ul>
            <p>
                JPEG格式对应的CreateCopy的代码如下：</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">static GDALDataset *
JPEGCreateCopy( const char * pszFilename, GDALDataset *poSrcDS,
                int bStrict, char ** papszOptions,
                GDALProgressFunc pfnProgress, void * pProgressData )

{
    int  nBands = poSrcDS-&gt;GetRasterCount();
    int  nXSize = poSrcDS-&gt;GetRasterXSize();
    int  nYSize = poSrcDS-&gt;GetRasterYSize();
    int  nQuality = 75;
    int  bProgressive = FALSE;

// --------------------------------------------------------------------
//      Some some rudimentary checks
// --------------------------------------------------------------------
    if( nBands != 1 &amp;&amp; nBands != 3 )
    {
        CPLError( CE_Failure, CPLE_NotSupported,
                  "JPEG driver doesn't support %d bands.  Must be 1 (grey) "
                  "or 3 (RGB) bands.\n", nBands );

        return NULL;
    }

    if( poSrcDS-&gt;GetRasterBand(1)-&gt;GetRasterDataType() != GDT_Byte &amp;&amp; bStrict )
    {
        CPLError( CE_Failure, CPLE_NotSupported,
                  "JPEG driver doesn't support data type %s. "
                  "Only eight bit byte bands supported.\n",
                  GDALGetDataTypeName(
                      poSrcDS-&gt;GetRasterBand(1)-&gt;GetRasterDataType()) );

        return NULL;
    }

// --------------------------------------------------------------------
//      What options has the user selected?
// --------------------------------------------------------------------
    if( CSLFetchNameValue(papszOptions,"QUALITY") != NULL )
    {
        nQuality = atoi(CSLFetchNameValue(papszOptions,"QUALITY"));
        if( nQuality &lt; 10 || nQuality &gt; 100 )
        {
            CPLError( CE_Failure, CPLE_IllegalArg,
                      "QUALITY=%s is not a legal value in the range 10-100.",
                      CSLFetchNameValue(papszOptions,"QUALITY") );
            return NULL;
        }
    }

    if( CSLFetchNameValue(papszOptions,"PROGRESSIVE") != NULL )
    {
        bProgressive = TRUE;
    }

// --------------------------------------------------------------------
//      Create the dataset.
// --------------------------------------------------------------------
    FILE	*fpImage;

    fpImage = VSIFOpen( pszFilename, "wb" );
    if( fpImage == NULL )
    {
        CPLError( CE_Failure, CPLE_OpenFailed,
                  "Unable to create jpeg file %s.\n",
                  pszFilename );
        return NULL;
    }

// --------------------------------------------------------------------
//      Initialize JPG access to the file.
// --------------------------------------------------------------------
    struct jpeg_compress_struct sCInfo;
    struct jpeg_error_mgr sJErr;

    sCInfo.err = jpeg_std_error( &amp;sJErr );
    jpeg_create_compress( &amp;sCInfo );

    jpeg_stdio_dest( &amp;sCInfo, fpImage );

    sCInfo.image_width = nXSize;
    sCInfo.image_height = nYSize;
    sCInfo.input_components = nBands;

    if( nBands == 1 )
    {
        sCInfo.in_color_space = JCS_GRAYSCALE;
    }
    else
    {
        sCInfo.in_color_space = JCS_RGB;
    }

    jpeg_set_defaults( &amp;sCInfo );

    jpeg_set_quality( &amp;sCInfo, nQuality, TRUE );

    if( bProgressive )
        jpeg_simple_progression( &amp;sCInfo );

    jpeg_start_compress( &amp;sCInfo, TRUE );

// --------------------------------------------------------------------
//      Loop over image, copying image data.
// --------------------------------------------------------------------
    GByte 	*pabyScanline;
    CPLErr      eErr;

    pabyScanline = (GByte *) CPLMalloc( nBands * nXSize );

    for( int iLine = 0; iLine &lt; nYSize; iLine++ )
    {
        JSAMPLE      *ppSamples;

        for( int iBand = 0; iBand &lt; nBands; iBand++ )
        {
            GDALRasterBand * poBand = poSrcDS-&gt;GetRasterBand( iBand+1 );
            eErr = poBand-&gt;RasterIO( GF_Read, 0, iLine, nXSize, 1,
                                     pabyScanline + iBand, nXSize, 1, GDT_Byte,
                                     nBands, nBands * nXSize );
        }

        ppSamples = pabyScanline;
        jpeg_write_scanlines( &amp;sCInfo, &amp;ppSamples, 1 );
    }

    CPLFree( pabyScanline );

    jpeg_finish_compress( &amp;sCInfo );
    jpeg_destroy_compress( &amp;sCInfo );

    VSIFClose( fpImage );

    return (GDALDataset *) GDALOpen( pszFilename, GA_ReadOnly );
}
</pre>
            </div>
            <h3><a class="anchor" name="gdal_drivertut_creation_create">
                动态创建</a></h3>
            在动态创建的例子中，没有源数据。但是提供了文件的大小、波段数和像素的数据类型。 对于其他的一些信息（例如地理参照系等），将在以后通过特定的函数设置。<p>
            接下来的自立简单实现了PCI.aux标记的原始矢量创建。它采用的自己的方法创建了一个 空白，并且在最后调用GDALOpen。这避免在Open函数中出现两套不同的启动过程。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">GDALDataset *PAuxDataset::Create( const char * pszFilename,
                                  int nXSize, int nYSize, int nBands,
                                  GDALDataType eType,
                                  char ** // papszParmList  )

{
    char	*pszAuxFilename;

// --------------------------------------------------------------------
//      Verify input options.
// --------------------------------------------------------------------
    if( eType != GDT_Byte &amp;&amp; eType != GDT_Float32 &amp;&amp; eType != GDT_UInt16
        &amp;&amp; eType != GDT_Int16 )
    {
        CPLError( CE_Failure, CPLE_AppDefined,
              "Attempt to create PCI .Aux labelled dataset with an illegal\n"
              "data type (%s).\n",
              GDALGetDataTypeName(eType) );

        return NULL;
    }

// --------------------------------------------------------------------
//      Try to create the file.
// --------------------------------------------------------------------
    FILE	*fp;

    fp = VSIFOpen( pszFilename, "w" );

    if( fp == NULL )
    {
        CPLError( CE_Failure, CPLE_OpenFailed,
                  "Attempt to create file `%s' failed.\n",
                  pszFilename );
        return NULL;
    }

// --------------------------------------------------------------------
//      Just write out a couple of bytes to establish the binary
//      file, and then close it.
// --------------------------------------------------------------------
    VSIFWrite( (void *) "\0\0", 2, 1, fp );
    VSIFClose( fp );

// --------------------------------------------------------------------
//      Create the aux filename.
// --------------------------------------------------------------------
    pszAuxFilename = (char *) CPLMalloc(strlen(pszFilename)+5);
    strcpy( pszAuxFilename, pszFilename );;

    for( int i = strlen(pszAuxFilename)-1; i &gt; 0; i-- )
    {
        if( pszAuxFilename[i] == '.' )
        {
            pszAuxFilename[i] = '\0';
            break;
        }
    }

    strcat( pszAuxFilename, ".aux" );

// --------------------------------------------------------------------
//      Open the file.
// --------------------------------------------------------------------
    fp = VSIFOpen( pszAuxFilename, "wt" );
    if( fp == NULL )
    {
        CPLError( CE_Failure, CPLE_OpenFailed,
                  "Attempt to create file `%s' failed.\n",
                  pszAuxFilename );
        return NULL;
    }

// --------------------------------------------------------------------
//      We need to write out the original filename but without any
//      path components in the AuxilaryTarget line.  Do so now.
// --------------------------------------------------------------------
    int		iStart;

    iStart = strlen(pszFilename)-1;
    while( iStart &gt; 0 &amp;&amp; pszFilename[iStart-1] != '/'
           &amp;&amp; pszFilename[iStart-1] != '\\' )
        iStart--;

    VSIFPrintf( fp, "AuxilaryTarget: %s\n", pszFilename + iStart );

// --------------------------------------------------------------------
//      Write out the raw definition for the dataset as a whole.
// --------------------------------------------------------------------
    VSIFPrintf( fp, "RawDefinition: %d %d %d\n",
                nXSize, nYSize, nBands );

// --------------------------------------------------------------------
//      Write out a definition for each band.  We always write band
//      sequential files for now as these are pretty efficiently
//      handled by GDAL.
// --------------------------------------------------------------------
    int		nImgOffset = 0;

    for( int iBand = 0; iBand &lt; nBands; iBand++ )
    {
        const char * pszTypeName;
        int	     nPixelOffset;
        int	     nLineOffset;

        nPixelOffset = GDALGetDataTypeSize(eType)/8;
        nLineOffset = nXSize * nPixelOffset;

        if( eType == GDT_Float32 )
            pszTypeName = "32R";
        else if( eType == GDT_Int16 )
            pszTypeName = "16S";
        else if( eType == GDT_UInt16 )
            pszTypeName = "16U";
        else
            pszTypeName = "8U";

        VSIFPrintf( fp, "ChanDefinition-%d: %s %d %d %d %s\n",
                    iBand+1, pszTypeName,
                    nImgOffset, nPixelOffset, nLineOffset,
#ifdef CPL_LSB
                    "Swapped"
#else
                    "Unswapped"
#endif
                    );

        nImgOffset += nYSize * nLineOffset;
    }

// --------------------------------------------------------------------
//      Cleanup
// --------------------------------------------------------------------
    VSIFClose( fp );

    return (GDALDataset *) GDALOpen( pszFilename, GA_Update );
}
</pre>
            </div>
            <p>
                文件格式支持动态创建或支持更新都需要实现GDALRasterBand中的IWriteBlock()方法。 它类似于IReadBlock()。并且，因为许多理由，在GDALRasterBand的析构中实现
                FlushCache()方法是比较危险的。因此，必须确保在析构方法调用之前，带的任何 写缓冲区块都被清除。</p>

            <h2><a class="anchor" name="gdal_drivertut_raw">
                RawDataset/RawRasterBand Helper Classes</a></h2>
            Many file formats have the actual imagery data stored in a regular, binary, scanline oriented format. Rather
            than re-implement the access semantics for this for each formats, there are provided RawDataset and
            RawRasterBand classes declared in gdal/frmts/raw that can be utilized to implement efficient and convenient
            access.<p>
            In these cases the format specific band class may not be required, or if required it can be derived from
            RawRasterBand. The dataset class should be derived from RawDataset.</p>

            <p>
                The Open() method for the dataset then instantiates raster bands passing all the layout information to
                the constructor. For instance, the PNM driver uses the following calls to create it's raster bands.</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span>( poOpenInfo-&gt;pabyHeader[1] == <span
                    class="charliteral">'5'</span> )
    {
        poDS-&gt;SetBand( 
            1, <span class="keyword">new</span> RawRasterBand( poDS, 1, poDS-&gt;fpImage,
                                  iIn, 1, nWidth, GDT_Byte, TRUE ));
    }
    <span class="keywordflow">else</span> 
    {
        poDS-&gt;SetBand( 
            1, <span class="keyword">new</span> RawRasterBand( poDS, 1, poDS-&gt;fpImage,
                                  iIn, 3, nWidth*3, GDT_Byte, TRUE ));
        poDS-&gt;SetBand( 
            2, <span class="keyword">new</span> RawRasterBand( poDS, 2, poDS-&gt;fpImage,
                                  iIn+1, 3, nWidth*3, GDT_Byte, TRUE ));
        poDS-&gt;SetBand( 
            3, <span class="keyword">new</span> RawRasterBand( poDS, 3, poDS-&gt;fpImage,
                                  iIn+2, 3, nWidth*3, GDT_Byte, TRUE ));
    }
</pre>
            </div>
            <p>
                The RawRasterBand takes the following arguments.</p>

            <p>
            </p>
            <ul>
                <li>
                    <b>poDS</b>: The GDALDataset this band will be a child of. This dataset must be of a class derived
                    from RawRasterDataset.
                </li>
                <li>
                    <b>nBand</b>: The band it is on that dataset, 1 based.
                </li>
                <li>
                    <b>fpRaw</b>: The FILE * handle to the file containing the raster data.
                </li>
                <li>
                    <b>nImgOffset</b>: The byte offset to the first pixel of raster data for the first scanline.
                </li>
                <li>
                    <b>nPixelOffset</b>: The byte offset from the start of one pixel to the start of the next within the
                    scanline.
                </li>
                <li>
                    <b>nLineOffset</b>: The byte offset from the start of one scanline to the start of the next.
                </li>
                <li>
                    <b>eDataType</b>: The GDALDataType code for the type of the data on disk.
                </li>
                <li>
                    <b>bNativeOrder</b>: FALSE if the data is not in the same endianness as the machine GDAL is running
                    on. The data will be automatically byte swapped.
                </li>
            </ul>
            <p>
                Simple file formats utilizing the Raw services are normally placed all within one file in the
                gdal/frmts/raw directory. There are numerous examples there of format implementation.</p>

            <h2><a class="anchor" name="gdal_drivertut_metadata">
                元数据以及其他扩展</a></h2>
            在GDAL数据模型中有很多其他项，在GDALDataset和GDALRasterBand中存在对应的虚函数。 它们包括：<p>
        </p>
            <ul>
                <li>
                    <b>Metadata</b>: 关于数据集或者波段的Name/value。GDALMajorObject（包括其子类） 支持元数据，可以在Open()函数中调用
                    SetMetadataItem()设置。 SAR_CEOS(frmts/ceos2/sar_ceosdataset.cpp)和GeoTIFF驱动是实现可读元数据的例子。<p>
                </p></li>
                <li>
                    <b>ColorTables</b>: GDT_Byte类型的波段可以含有与它们相关联的颜色表。 frmts/png/pngdataset.cpp对应的驱动是一个致支持颜色表的例子。<p>
                </p></li>
                <li>
                    <b>ColorInterpretation</b>: PNG驱动包括一个驱动返回一个波段被表示为 红，绿，蓝，透明度或者灰度的描述。<p>
                </p></li>
                <li>
                    <b>GCPs</b>:GDALDataset有一系列大地控制点与他们相关联关联矢量到地理
                    参照系（通过GetGeoTransform来映射转换）。MFF2格式（gdal/frmts.raw.hkvdataset.cpp） 是一个简单的支持GCP的例子。<p>
                </p></li>
                <li>
                    <b>NoDataValue</b>: GetNoDataValue()可以判断波段是否是"nodata"。 参考frmts/raw/pauxdataset.cpp驱动。<p>
                </p></li>
                <li>
                    <b>Category Names</b>: GetCategoryNames()函数可以根据影象的名字将其分类。 不过目前还没有哪个驱动用到这个特性。<p>
                </p></li>
            </ul>



        </div>
    </div>
</div>
{% end %}
