{% extends "../../../../theme/content.html" %}

{% block headinfo %}


<title>OGR API 使用向导</title>

{% end %}


{% block content %}

<div class="content">

    <div class="single">

        <h1><a class="anchor" name="ogr_apitut">OGR API 使用向导 </a></h1>

        <div class="entry">


            <em> <b>翻译：</b>柴树杉(<a href="mailto:chaishushan@gmail.com">chaishushan@gmail.com</a>) <br>
                <b>原文：</b><a href="http://www.gdal.org/ogr/ogr_apitut.html">http://www.gdal.org/ogr/ogr_apitut.html</a>
                <br>
            </em>

            <p>
                该文档讲述了怎么样用OGR的类读/写一个文件。其中侧重介绍了OGR中一些比较关键类的用法。</p>

            <h2><a class="anchor" name="ogr_apitut_read">
                用OGR读</a></h2>
            为了演示怎么用OGR读数据，我们创建了一个小程序：从数据源中读point层， 然后用逗号分隔格式输出到stdout。开始的时候一般需要注册所有格式的驱动， 可以通过调用OGRRegisterAll()函数实现。<p>
        </p>

            <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "ogrsf_frmts.h"</span>

<span class="keywordtype">int</span> main()

{
        OGRRegisterAll();
</pre>
            </div>
            <p>
                接下来需要打开用于输入的数据源（Datasources）。Datasources可以是文件、RDBMSes、 目录中的所有文件或者是被连接到本机的 web地址。通常，datasource都对应一个字符串
                的名字。在这个例子中，我们将要打开一个名point.shp为的shapefile格式的文件。 第二个参数FALSE表示<code>OGRSFDriverRegistrar::Open()</code>方法并不需要更新的权限。
                如果操作失败，则会返回NULL，我们则简单输出失败的信息。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    OGRDataSource       *poDS;

    poDS = OGRSFDriverRegistrar::Open( <span class="stringliteral">"point.shp"</span>, FALSE );
    <span class="keywordflow">if</span>( poDS == NULL )
    {
        printf( <span class="stringliteral">"Open failed.\n"</span> );
        exit( 1 );
    }
</pre>
            </div>
            <p>
                一个OGRDataSource一般含有许多层（layer）。<code>OGRDataSource::GetLayerCount()</code> 可以返回
                OGRDataSource中层的总数目。<code>OGRDataSource::GetLayer()</code>可以通过层 的索引编号获取一个层。当然，这个例子中我们是通过层的名字访问层。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    OGRLayer  *poLayer;

    poLayer = poDS-&gt;GetLayerByName( <span class="stringliteral">"point"</span> );
</pre>
            </div>
            <p>
                现在我们可以从获取的层中读取各种实体了（feature）。在读之前，我们可以设置 一个过滤器，那样的话后面顺序返回的将都是没有被过滤的实体。这里我们是获取层 中所有的实体。</p>

            <p>
                在我们从层中读实体之前需要调用<code>OGRLayer::ResetReading()</code>函数重新设置读操作 （即定位到开头）。然后<code>OGRLayer::GetNextFeature()</code>依次返回下一个实体，如果
                返回NULL的话表示全部读完。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    OGRFeature *poFeature;

    poLayer-&gt;ResetReading();
    <span class="keywordflow">while</span>( (poFeature = poLayer-&gt;GetNextFeature()) != NULL )
    {
</pre>
            </div>
            <p>
                为了获取实体的每个属性字段的信息，可以获取OGRFeatureDefn。OGRFeatureDefn是 一个和当前层相关的对象，它包含了该层中定义的所有属性字段。我们循环访问所有的
                属性字段，并且输出每个字段对应的值。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">        OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn();
        <span class="keywordtype">int</span> iField;

        <span class="keywordflow">for</span>( iField = 0; iField &lt; poFDefn-&gt;GetFieldCount(); iField++ )
        {
            OGRFieldDefn *poFieldDefn = poFDefn-&gt;GetFieldDefn( iField );

            <span class="keywordflow">if</span>( poFieldDefn-&gt;GetType() == OFTInteger )
                printf( <span class="stringliteral">"%d,"</span>, poFeature-&gt;GetFieldAsInteger( iField ) );
            <span class="keywordflow">else</span> <span class="keywordflow">if</span>( poFieldDefn-&gt;GetType() == OFTReal )
                printf( <span class="stringliteral">"%.3f,"</span>, poFeature-&gt;GetFieldAsDouble(iField) );
            <span class="keywordflow">else</span> <span class="keywordflow">if</span>( poFieldDefn-&gt;GetType() == OFTString )
                printf( <span class="stringliteral">"%s,"</span>, poFeature-&gt;GetFieldAsString(iField) );
            <span class="keywordflow">else</span>
                printf( <span class="stringliteral">"%s,"</span>, poFeature-&gt;GetFieldAsString(iField) );
        }
</pre>
            </div>
            <p>
                这里只有很少的几种字段类型。并且任何类型的字段都可以用<code>OGRFeature::GetFieldAsString()</code>
                方法获取。接下来我们从实体中导出集合图元，并且输出点图元的坐标。几何图元以OGRGeometry 指针的方式返回。我们可以判断几何图元的类型，如果是点则输出坐标，如果不是则输出提示信息。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">        OGRGeometry *poGeometry;

        poGeometry = poFeature-&gt;GetGeometryRef();
        <span class="keywordflow">if</span>( poGeometry != NULL 
            &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint )
        {
            OGRPoint *poPoint = (OGRPoint *) poGeometry;

            printf( <span class="stringliteral">"%.3f,%3.f\n"</span>, poPoint-&gt;getX(), poPoint-&gt;getY() );
        }
        <span class="keywordflow">else</span>
        {
            printf( <span class="stringliteral">"no point geometry\n"</span> );
        }       
</pre>
            </div>
            <p>
                上面代码中的wkbFlatten()宏用于将wkbPoint25D类型（含有z坐标的点）转换为2D的类型。 每个2D的集合图元类型都对应一个 2.5D的编码，然而这里只有一个C++类用于处理2D和3D
                情形，因此我们在代码中可能需要对2D或3D情形做适当的处理。</p>

            <p>
                需要注意的是<code>OGRFeature::GetGeometryRef()</code>返回的是OGRFeature中数据的的指针， 因此用完之后我们不能删除
                poGeometry指针对应内容。但是<code>OGRLayer::GetNextFeature()</code> 返回的是层中当前实体的一个拷贝，因此在使用完 poFeature之后必须手工释放。
                释放poFeature不能直接delete，正确的方式是用OGR提供的 <code>OGRFeature::DestroyFeature()</code> 函数释放。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">        OGRFeature::DestroyFeature( poFeature );
    }
</pre>
            </div>
            <p>
                <code>OGRDataSource::GetLayerByName()</code> 返回的OGRLayer是OGRDataSource中数据的引用，
                因此我们可以不用delete它。但是我们需要删除OGRDataSource本身，这样才会关闭文件。 同样，我们用<code>OGRFeature::DestroyFeature()</code>函数删除poDS（delete
                poDS在win32系统 上可能出现问题）。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    OGRDataSource::DestroyDataSource( poDS );
}
</pre>
            </div>
            <p>
                所有的程序合到一起如下：</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "ogrsf_frmts.h"</span>

<span class="keywordtype">int</span> main()

{
    OGRRegisterAll();

    OGRDataSource       *poDS;

    poDS = OGRSFDriverRegistrar::Open( <span class="stringliteral">"point.shp"</span>, FALSE );
    <span class="keywordflow">if</span>( poDS == NULL )
    {
        printf( <span class="stringliteral">"Open failed.\n%s"</span> );
        exit( 1 );
    }

    OGRLayer  *poLayer;

    poLayer = poDS-&gt;GetLayerByName( <span class="stringliteral">"point"</span> );

    OGRFeature *poFeature;

    poLayer-&gt;ResetReading();
    <span class="keywordflow">while</span>( (poFeature = poLayer-&gt;GetNextFeature()) != NULL )
    {
        OGRFeatureDefn *poFDefn = poLayer-&gt;GetLayerDefn();
        <span class="keywordtype">int</span> iField;

        <span class="keywordflow">for</span>( iField = 0; iField &lt; poFDefn-&gt;GetFieldCount(); iField++ )
        {
            OGRFieldDefn *poFieldDefn = poFDefn-&gt;GetFieldDefn( iField );

            <span class="keywordflow">if</span>( poFieldDefn-&gt;GetType() == OFTInteger )
                printf( <span class="stringliteral">"%d,"</span>, poFeature-&gt;GetFieldAsInteger( iField ) );
            <span class="keywordflow">else</span> <span class="keywordflow">if</span>( poFieldDefn-&gt;GetType() == OFTReal )
                printf( <span class="stringliteral">"%.3f,"</span>, poFeature-&gt;GetFieldAsDouble(iField) );
            <span class="keywordflow">else</span> <span class="keywordflow">if</span>( poFieldDefn-&gt;GetType() == OFTString )
                printf( <span class="stringliteral">"%s,"</span>, poFeature-&gt;GetFieldAsString(iField) );
            <span class="keywordflow">else</span>
                printf( <span class="stringliteral">"%s,"</span>, poFeature-&gt;GetFieldAsString(iField) );
        }

        OGRGeometry *poGeometry;

        poGeometry = poFeature-&gt;GetGeometryRef();
        <span class="keywordflow">if</span>( poGeometry != NULL 
            &amp;&amp; wkbFlatten(poGeometry-&gt;getGeometryType()) == wkbPoint )
        {
            OGRPoint *poPoint = (OGRPoint *) poGeometry;

            printf( <span class="stringliteral">"%.3f,%3.f\n"</span>, poPoint-&gt;getX(), poPoint-&gt;getY() );
        }
        <span class="keywordflow">else</span>
        {
            printf( <span class="stringliteral">"no point geometry\n"</span> );
        }       
        OGRFeature::DestroyFeature( poFeature );
    }

    OGRDataSource::DestroyDataSource( poDS );
}
</pre>
            </div>
            <h2><a class="anchor" name="ogr_apitut_write">
                用OGR写</a></h2>
            作为用OGR写数据的例子，下面的程序中stdin顺序读以逗号分割的点坐标，然后保存 到point_out.shp文件。和写一样，在程序开头需要注册所有的驱动。然后我们获取 一个相应格式的驱动用于创建输出文件。<p>
        </p>

            <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "ogrsf_frmts.h"</span>

<span class="keywordtype">int</span> main()
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> *pszDriverName = <span
                        class="stringliteral">"ESRI Shapefile"</span>;
    OGRSFDriver *poDriver;

    OGRRegisterAll();

    poDriver = OGRSFDriverRegistrar::GetRegistrar()-&gt;GetDriverByName(
                pszDriverName );
    <span class="keywordflow">if</span>( poDriver == NULL )
    {
        printf( <span class="stringliteral">"%s driver not available.\n"</span>, pszDriverName );
        exit( 1 );
    }
</pre>
            </div>
            <p>
                接着我们创建一个datasource（和驱动是相同的格式）。ESRI Shapefile格式的驱动 可以支持创建多个shapefiles（在一个木中），也可以支持创建一个单一的shapefile。
                这里，我们通过指定.shp扩展名表示创建一个单一的shapefile。其他格式的驱动调用规则 可能并不相同。第二个参数是一个选项列表（是一个以NULL结尾的字符串数组），
                这里我们采用默认选项。选项列表的规则根据格式的不同而不同。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    OGRDataSource *poDS;

    poDS = poDriver-&gt;CreateDataSource( <span class="stringliteral">"point_out.shp"</span>, NULL );
    <span class="keywordflow">if</span>( poDS == NULL )
    {
        printf( <span class="stringliteral">"Creation of output file failed.\n"</span> );
        exit( 1 );
    }
</pre>
            </div>
            <p>
                现在我们创建一个用于输出的层。在这个程序中，因为datasource只对应一个单一的 文件，因此只能创建一个层。参数wkbPoint表示该曾需要支持的类型。在该程序中，
                同样不能指定任何坐标系统或者其他特殊的选项。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    OGRLayer *poLayer;

    poLayer = poDS-&gt;CreateLayer( <span class="stringliteral">"point_out"</span>, NULL, wkbPoint, NULL );
    <span class="keywordflow">if</span>( poLayer == NULL )
    {
        printf( <span class="stringliteral">"Layer creation failed.\n"</span> );
        exit( 1 );
    }
</pre>
            </div>
            <p>
                层被创建之后，我们可以为层定义任何需要的属性字段。属性字段必须在任何 实体添加到层之前被写入。我们创建一个属性字段对象，并且初始化。在 Shapefiles中，
                width和precision是比较重要的被创建在.dbf文件中，这里我们对它单独设置。 在这个程序中我们只创建了一个属性，即点的名字。</p>

            <p>
                需要注意的是CreateField()将OGRField重新复制了一份，因此我们仍然持有oField的所有权。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    OGRFieldDefn oField( <span
                    class="stringliteral">"Name"</span>, OFTString );

    oField.SetWidth(32);

    <span class="keywordflow">if</span>( poLayer-&gt;CreateField( &amp;oField ) != OGRERR_NONE )
    {
        printf( <span class="stringliteral">"Creating Name field failed.\n"</span> );
        exit( 1 );
    }
\encode

下面从stdin中循环读取<span class="stringliteral">"x,y,name"</span>格式的点信息。

\code
    <span class="keywordtype">double</span> x, y;
    <span class="keywordtype">char</span> szName[33];

    <span class="keywordflow">while</span>( !feof(stdin) 
           &amp;&amp; fscanf( stdin, <span class="stringliteral">"%lf,%lf,%32s"</span>, &amp;x, &amp;y, szName ) == 3 )
    {
</pre>
            </div>
            <p>
                为了将feature写入磁盘，我们需要创建一个OGRFeature对象，并且和层对应的属性 帮定（即需要和OGRFeatureDefn关联）。然后设置feature的相关属性。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">        OGRFeature *poFeature;

        poFeature = <span class="keyword">new</span> OGRFeature( poLayer-&gt;GetLayerDefn() );
        poFeature-&gt;SetField( <span class="stringliteral">"Name"</span>, szName );
</pre>
            </div>
            <p>
                现在我们创建一个具体的几何图元，然后将它的拷贝指定给feature。 <code>OGRFeature::SetGeometryDirectly()</code>和 <code>OGRFeature::SetGeometry()</code>函数的不同
                是SetGeometryDirectly函数将几何图元的所有全给予feature。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">        OGRPoint pt;
        pt.setX( x );
        pt.setY( y );
        
        poFeature-&gt;SetGeometry( &amp;pt ); 
</pre>
            </div>
            <p>
                创建一个feature。<code>OGRLayer::CreateFeature()</code>只是重新复制了一个feature，因此 操作完成后需要清除feature对象。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">        <span class="keywordflow">if</span>( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE )
        {
           printf( <span class="stringliteral">"Failed to create feature in shapefile.\n"</span> );
           exit( 1 );
        }
        
        OGRFeature::DestroyFeature( poFeature );
   }
</pre>
            </div>
            <p>
                最后释放datasource资源，刷新所有的写操作。</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment">    OGRDataSource::DestroyDataSource( poDS );
}
</pre>
            </div>
            <p>
                所有的程序合到一起如下：</p>

            <p>
            </p>

            <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "ogrsf_frmts.h"</span>

<span class="keywordtype">int</span> main()
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> *pszDriverName = <span
                        class="stringliteral">"ESRI Shapefile"</span>;
    OGRSFDriver *poDriver;

    OGRRegisterAll();

    poDriver = OGRSFDriverRegistrar::GetRegistrar()-&gt;GetDriverByName(
                pszDriverName );
    <span class="keywordflow">if</span>( poDriver == NULL )
    {
        printf( <span class="stringliteral">"%s driver not available.\n"</span>, pszDriverName );
        exit( 1 );
    }

    OGRDataSource *poDS;

    poDS = poDriver-&gt;CreateDataSource( <span class="stringliteral">"point_out.shp"</span>, NULL );
    <span class="keywordflow">if</span>( poDS == NULL )
    {
        printf( <span class="stringliteral">"Creation of output file failed.\n"</span> );
        exit( 1 );
    }

    OGRLayer *poLayer;

    poLayer = poDS-&gt;CreateLayer( <span class="stringliteral">"point_out"</span>, NULL, wkbPoint, NULL );
    <span class="keywordflow">if</span>( poLayer == NULL )
    {
        printf( <span class="stringliteral">"Layer creation failed.\n"</span> );
        exit( 1 );
    }

    OGRFieldDefn oField( <span class="stringliteral">"Name"</span>, OFTString );

    oField.SetWidth(32);

    <span class="keywordflow">if</span>( poLayer-&gt;CreateField( &amp;oField ) != OGRERR_NONE )
    {
        printf( <span class="stringliteral">"Creating Name field failed.\n"</span> );
        exit( 1 );
    }

    <span class="keywordtype">double</span> x, y;
    <span class="keywordtype">char</span> szName[33];

    <span class="keywordflow">while</span>( !feof(stdin) 
           &amp;&amp; fscanf( stdin, <span class="stringliteral">"%lf,%lf,%32s"</span>, &amp;x, &amp;y, szName ) == 3 )
    {
        OGRFeature *poFeature;

        poFeature = <span class="keyword">new</span> OGRFeature( poLayer-&gt;GetLayerDefn() );
        poFeature-&gt;SetField( <span class="stringliteral">"Name"</span>, szName );

        OGRPoint pt;
        
        pt.setX( x );
        pt.setY( y );
 
        poFeature-&gt;SetGeometry( &amp;pt ); 

        <span class="keywordflow">if</span>( poLayer-&gt;CreateFeature( poFeature ) != OGRERR_NONE )
        {
           printf( <span class="stringliteral">"Failed to create feature in shapefile.\n"</span> );
           exit( 1 );
        }

         OGRFeature::DestroyFeature( poFeature );
    }

    OGRDataSource::DestroyDataSource( poDS );
}
</pre>
            </div>


        </div>
    </div>
</div>
{% end %}
